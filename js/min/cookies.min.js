class Cookies {
    constructor(duration) {
        this.duration = this.assertDuration(duration);
        this.read('');
    }

    assertDuration (millis) {
        const parsed = !isNaN(millis) ? parseInt(millis) : false;
        if (parsed === false)
        { throw new Error('Invalid duration; Should be Number of ms. (Is ' + typeof millis + ')'); }
        return parsed;
    }

    expireTimestamp (duration = this.duration) {
        duration = this.assertDuration(duration);
        const date = new Date();
        date.setTime(date.getTime() + duration + (-1*date.getTimezoneOffset()*60*1000));
        return date.toUTCString();
    }

    expired (name) {
        if (typeof this.cache[name] === 'undefined') { return; }
        this.delete(name);
    }

    create (name, value, duration = this.duration) {
        duration = this.assertDuration(duration);
        const expires = setTimeout( () => { this.expired(name); }, duration );
        const exTime = this.expireTimestamp(duration);
        const val = value ? { value: value, expires: expires, fallbackTime: exTime } : '';
        document.cookie = name + '=' + JSON.stringify(val) + '; expires=' + exTime + '; path=/';
        this.cache[name] = { value: value, expires:  expires, fallbackTime: exTime };
    }

    read (name) {
        if (this.cache && typeof this.cache[name] !== 'undefined' && typeof this.cache[name].expires !== 'undefined') { return this.cache[name].value; }
        const cookies = document.cookie.split('; ');
        this.cache = {};
        for (let i = 0; i < cookies.length; i++) {
            const cookieName = cookies[i].substr(0, cookies[i].indexOf('='));
            const cookieJSON = cookies[i].substr(cookies[i].indexOf('=')+1);
            const notNull = typeof cookieJSON !== 'undefined' && cookieJSON !== 'undefined';
            const cookieValue = notNull && cookieJSON ? JSON.parse(cookieJSON) : undefined;
            if (cookieValue && cookieValue.hasOwnProperty('fallbackTime')) {
                const fbT = new Date(cookieValue.fallbackTime);
                const now = new Date();
                now.setTime(now.getTime() + (-1*now.getTimezoneOffset()*60*1000));
                if (fbT.getTime() > now.getTime()) {
                    this.cache[cookieName] = cookieValue;
                } else { this.delete(cookieName); }
            }
        }
        return this.cache[name] ? this.cache[name].value : null;
    }

    extendDuration (name, duration = this.duration) {
        duration = this.assertDuration(duration);
        if (typeof this.cache[name] === 'undefined')
        { throw new Error('Can not extend duration of undefined cookie.'); }
        else {
            const oldCookie = this.cache[name];
            const fbT = new Date(oldCookie.fallbackTime);
            const now = new Date();
            now.setTime(now.getTime() + (-1*now.getTimezoneOffset()*60*1000));
            if (!fbT.getTime() > now.getTime()) {
                this.delete(name);
                throw new Error('Can not extentd duration of expired cookie.');
            } else {
                clearTimeout(oldCookie.expires);
                this.create(name, oldCookie.value, duration ? duration : this.duration);
            }
        }
    }

    delete (name) {
        if (typeof this.cache[name] === 'undefined') { return; }
        this.create(name, '', -1);
        delete this.cache[name];
    }
}
const cookie = new Cookies(10*60*1000);